策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
    在demo中，使用if else方式来判断当前类型及对应得电影票价，把不同得价格得计算方法放在同一个类里面
    如果要新增儿童票5折，就需要修改MovieTicket这个类，违反OCP开闭原则中得对修改关闭。
策略模式可以很好得解决上面出现得这种情况：
  首先在策略模式中得3中对象：策略接口角色、策略具体角色和策略上下文环境;
  策略接口角色：约定一些策略算法，
  策略具体角色：实现策略接口角色中策略算法。
  上下文环境：具体负责和策略之间得交互，持有策略的引用

使用策略模式的上下文环境，体现开闭原则。
类进行扩展时，只需要新增再新增策略具体角色即可。但是上下文环境需要修改

使用策略模式的具体策略，体现开闭原则。
类进行扩展时，只需要新增再新增策略具体角色即可，新增角色需要添加东西，但与其他策略风格不同。

策略模式也可不要上下文环境，再客户端直接设置策略。算法的定义和使用分离。但这样会违反单一职责和迪米特法则。
单一职责：策略类是采用那种算法执行相关操作，仅调用自己执行方法。
迪米特法则：两个类必须通信要借助第三方。

策略模式在JDK中的应用：
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
RejectedExecutionHandler 采用策略模式

优点：相互替换扩展性好、避免多个if-else判断。
缺点：必须了解具体策略、增加策略类数量、算法在运行时只有一个不能适合多层次。